import cv2
import numpy as np

def undistort_phone_fisheye(image, f_phone_mm, f_lens_mm, sensor_size_mm, fov_degrees=180, output_resolution=None):
    """
    Undistort fisheye images from phone + external lens combo.
    
    Args:
        image: Input image (BGR)
        f_phone_mm: Phone camera focal length (mm)
        f_lens_mm: Fisheye lens focal length (mm)
        sensor_size_mm: (width, height) of phone sensor (mm)
        fov_degrees: Fisheye FOV (typically 180°)
        output_resolution: Output size (width, height)
    Returns:
        Undistorted image, calibration info
    """
    h, w = image.shape[:2]
    output_resolution = output_resolution or (w, h)
    out_w, out_h = output_resolution
    sensor_w_mm, sensor_h_mm = sensor_size_mm
    
    # 1. Calculate effective focal length
    d = 0  # Lens-to-phone distance (approx 0 for clip-on lenses)
    f_effective = 1 / (1/f_phone_mm + 1/f_lens_mm - d/(f_phone_mm*f_lens_mm))
    
    # 2. Calculate pixel pitch (mm/px)
    pixel_size_mm = (sensor_w_mm/w + sensor_h_mm/h)/2
    
    # 3. Create output grid (normalized)
    x = np.linspace(-1, 1, out_w, dtype=np.float32)
    y = np.linspace(-1, 1, out_h, dtype=np.float32)
    xx, yy = np.meshgrid(x, y)
    out_r = np.sqrt(xx**2 + yy**2)
    
    # 4. Fisheye projection (equidistant model)
    fov_rad = np.deg2rad(fov_degrees)
    theta = np.clip(out_r * (fov_rad/2), 0, fov_rad/2)
    
    # 5. Avoid division by zero
    mask = out_r > 1e-8
    inv_out_r = np.zeros_like(out_r)
    inv_out_r[mask] = 1.0 / out_r[mask]
    
    # 6. Convert to input coordinates with physical scaling
    in_r = np.tan(theta) * (f_effective / pixel_size_mm)
    in_x = in_r * xx * inv_out_r
    in_y = in_r * yy * inv_out_r
    
    # 7. Map to original image
    map_x = (in_x * (w/2) + (w/2)).astype(np.float32)
    map_y = (in_y * (h/2) + (h/2)).astype(np.float32)
    
    # 8. Remap with high-quality interpolation
    undistorted = cv2.remap(
        image, map_x, map_y,
        interpolation=cv2.INTER_LANCZOS4,
        borderMode=cv2.BORDER_CONSTANT,
        borderValue=(0, 0, 0)
    )
    
    # Calibration info
    calibration = {
        'effective_focal_length_mm': f_effective,
        'pixel_size_mm': pixel_size_mm,
        'mm_per_px': f_effective * pixel_size_mm / w
    }
    
    return undistorted, calibration

# Example: iPhone 12 + 180° fisheye lens
if __name__ == "__main__":
    img = cv2.imread("phone_fisheye.jpg")
    undistorted, calib = undistort_phone_fisheye(
        image=img,
        f_phone_mm=4.2,          # iPhone 12 main camera
        f_lens_mm=1.8,           # Typical fisheye attachment
        sensor_size_mm=(6.17, 4.55),  # iPhone 12 sensor
        fov_degrees=180,
        output_resolution=(1920, 1080)  # Full HD output
    )
    
    print(f"Calibration: {calib}")
    cv2.imwrite("undistorted_phone_output.jpg", undistorted)
