import cv2
import numpy as np
import threading
import queue
import time

class OptimizedDetector:
    def __init__(self):
        self.camera = cv2.VideoCapture(0)
        if not self.camera.isOpened():
            print("Error: Could not open camera")
            exit(1)
        
        # Camera properties
        self.camera.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        self.camera.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
        self.camera.set(cv2.CAP_PROP_FPS, 30)
        
        # Detection parameters
        self.min_radius = 10
        self.max_radius = 100
        self.circle_sensitivity = 30
        
        # Threading setup
        self.frame_queue = queue.Queue(maxsize=2)
        self.running = True
        self.capture_thread = threading.Thread(target=self.capture_frames)
        self.capture_thread.daemon = True
        self.capture_thread.start()
        
        # Mouse callback
        cv2.namedWindow("Camera Feed")
        cv2.setMouseCallback("Camera Feed", self.select_object)
        
        # Selected object storage
        self.selected_object = None

    def capture_frames(self):
        """Dedicated thread for fast frame capture"""
        while self.running:
            ret, frame = self.camera.read()
            if ret:
                frame = cv2.resize(frame, (640, 480))
                
                if self.frame_queue.full():
                    try:
                        self.frame_queue.get_nowait()
                    except queue.Empty:
                        pass
                self.frame_queue.put(frame)
            else:
                time.sleep(0.01)

    def detect_objects(self, frame):
        """Detect circles and ellipses"""
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        blurred = cv2.GaussianBlur(gray, (7, 7), 1.5)
        
        # Circles
        circles = cv2.HoughCircles(
            blurred, 
            cv2.HOUGH_GRADIENT, 
            dp=1.2, 
            minDist=30,
            param1=50,
            param2=self.circle_sensitivity,
            minRadius=self.min_radius,
            maxRadius=self.max_radius
        )
        
        detected = []
        
        if circles is not None:
            circles = np.uint16(np.around(circles))
            for i in circles[0, :]:
                detected.append(('circle', (i[0], i[1]), i[2]))
        
        # Ellipses
        edges = cv2.Canny(blurred, 30, 100)
        contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        for contour in contours:
            if len(contour) < 5:
                continue
            hull = cv2.convexHull(contour)
            if len(hull) < 5:
                continue
            try:
                ellipse = cv2.fitEllipse(hull)
                (center, axes, angle) = ellipse
                major_axis = max(axes)
                minor_axis = min(axes)
                if 10 < minor_axis < 150 and 0.3 < minor_axis/major_axis < 1.0:
                    detected.append(('ellipse', (int(center[0]), int(center[1])), 
                                   (int(axes[0]/2), int(axes[1]/2), angle)))
            except:
                continue
                
        return detected

    def select_object(self, event, x, y, flags, param):
        """Handle object selection by mouse click"""
        if event == cv2.EVENT_LBUTTONDOWN:
            self.selected_object = (x, y)

    def process_frame(self, frame):
        """Detect, highlight, and handle selection"""
        detected = self.detect_objects(frame)
        display_frame = frame.copy()
        overlay = np.zeros_like(display_frame, dtype=np.uint8)
        
        for obj_type, center, params in detected:
            mask = np.zeros(frame.shape[:2], dtype=np.uint8)
            
            if obj_type == 'circle':
                cv2.circle(mask, center, params, 255, -1)
            else:
                cv2.ellipse(mask, center, (params[0], params[1]), params[2], 0, 360, 255, -1)
            
            blue_overlay = np.zeros_like(display_frame, dtype=np.uint8)
            blue_overlay[:] = (255, 0, 0)  # Blue color
            
            overlay = cv2.add(overlay, cv2.bitwise_and(blue_overlay, blue_overlay, mask=mask))
            
            if self.selected_object:
                dist = np.linalg.norm(np.array(center) - np.array(self.selected_object))
                if dist < (params if obj_type == 'circle' else max(params[0], params[1])):
                    self.store_object(frame, obj_type, center, params)
                    self.running = False
                    break
        
        combined = cv2.addWeighted(display_frame, 1.0, overlay, 0.3, 0)
        return combined

    def store_object(self, frame, obj_type, center, params):
        """Store, display, and exit"""
        mask = np.zeros(frame.shape[:2], dtype=np.uint8)
        if obj_type == 'circle':
            cv2.circle(mask, center, params, 255, -1)
            radius = params
        else:
            cv2.ellipse(mask, center, (params[0], params[1]), params[2], 0, 360, 255, -1)
            radius = max(params[0], params[1])
        
        x, y = center
        size = int(radius * 1.5)
        x1, y1 = max(0, x - size), max(0, y - size)
        x2, y2 = min(frame.shape[1], x + size), min(frame.shape[0], y + size)
        
        if x2 > x1 and y2 > y1:
            cutout = cv2.bitwise_and(frame, frame, mask=mask)[y1:y2, x1:x2]
            cv2.imshow("Selected Object", cutout)
            cv2.imwrite(f"object_{time.time()}.png", cutout)
            cv2.waitKey(0)
            self.camera.release()
            cv2.destroyAllWindows()
            exit(0)

    def run(self):
        """Main loop"""
        while self.running:
            try:
                frame = self.frame_queue.get(timeout=0.5)
                display_frame = self.process_frame(frame)
                cv2.imshow("Camera Feed", display_frame)
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    self.running = False
                    break
            except queue.Empty:
                continue
                
        self.camera.release()
        cv2.destroyAllWindows()

if __name__ == "__main__":
    detector = OptimizedDetector()
    detector.run()
